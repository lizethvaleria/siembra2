'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var firebase = require('firebase');
require('firebase/database');
require('firebase/firestore');
require('firebase/storage');
var request = require('request');
var util = require('@firebase/util');
var logger = require('@firebase/logger');
var component = require('@firebase/component');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var firebase__default = /*#__PURE__*/_interopDefaultLegacy(firebase);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var firestore = firebase__default['default'].firestore, database = firebase__default['default'].database, storage = firebase__default['default'].storage;
/** If this environment variable is set, use it for the database emulator's address. */
var DATABASE_ADDRESS_ENV = 'FIREBASE_DATABASE_EMULATOR_HOST';
/** The default address for the local database emulator. */
var DATABASE_ADDRESS_DEFAULT = 'localhost:9000';
/** If this environment variable is set, use it for the Firestore emulator. */
var FIRESTORE_ADDRESS_ENV = 'FIRESTORE_EMULATOR_HOST';
/** The default address for the local Firestore emulator. */
var FIRESTORE_ADDRESS_DEFAULT = 'localhost:8080';
/** If this environment variable is set, use it for the Storage emulator. */
var FIREBASE_STORAGE_ADDRESS_ENV = 'FIREBASE_STORAGE_EMULATOR_HOST';
var CLOUD_STORAGE_ADDRESS_ENV = 'STORAGE_EMULATOR_HOST';
/** The default address for the local Firestore emulator. */
var STORAGE_ADDRESS_DEFAULT = 'localhost:9199';
/** Environment variable to locate the Emulator Hub */
var HUB_HOST_ENV = 'FIREBASE_EMULATOR_HUB';
/** The default address for the Emulator Hub */
var HUB_HOST_DEFAULT = 'localhost:4400';
/** The actual address for the database emulator */
var _databaseHost = undefined;
/** The actual address for the Firestore emulator */
var _firestoreHost = undefined;
/** The actual address for the Storage emulator */
var _storageHost = undefined;
/** The actual address for the Emulator Hub */
var _hubHost = undefined;
function createUnsecuredJwt(token, projectId) {
    // Unsecured JWTs use "none" as the algorithm.
    var header = {
        alg: 'none',
        kid: 'fakekid',
        type: 'JWT'
    };
    var project = projectId || 'fake-project';
    var iat = token.iat || 0;
    var uid = token.sub || token.uid || token.user_id;
    if (!uid) {
        throw new Error("Auth must contain 'sub', 'uid', or 'user_id' field!");
    }
    var payload = __assign({ 
        // Set all required fields to decent defaults
        iss: "https://securetoken.google.com/" + project, aud: project, iat: iat, exp: iat + 3600, auth_time: iat, sub: uid, user_id: uid, firebase: {
            sign_in_provider: 'custom',
            identities: {}
        } }, token);
    // Remove the uid option since it's not actually part of the token spec.
    if (payload.uid) {
        delete payload.uid;
    }
    // Unsecured JWTs use the empty string as a signature.
    var signature = '';
    return [
        util.base64.encodeString(JSON.stringify(header), /*webSafe=*/ false),
        util.base64.encodeString(JSON.stringify(payload), /*webSafe=*/ false),
        signature
    ].join('.');
}
function apps() {
    return firebase__default['default'].apps;
}
/** Construct an App authenticated with options.auth. */
function initializeTestApp(options) {
    var jwt = options.auth
        ? createUnsecuredJwt(options.auth, options.projectId)
        : undefined;
    return initializeApp(jwt, options.databaseName, options.projectId, options.storageBucket);
}
/** Construct an App authenticated as an admin user. */
function initializeAdminApp(options) {
    var admin = require('firebase-admin');
    var app = admin.initializeApp(getAppOptions(options.databaseName, options.projectId, options.storageBucket), getRandomAppName());
    if (options.projectId) {
        app.firestore().settings({
            host: getFirestoreHost(),
            ssl: false
        });
    }
    return app;
}
/**
 * Set the host and port configuration for applicable emulators. This will override any values
 * found in environment variables. Must be called before initializeAdminApp or initializeTestApp.
 *
 * @param options options object.
 */
function useEmulators(options) {
    if (!(options.database || options.firestore || options.storage || options.hub)) {
        throw new Error("Argument to useEmulators must contain at least one of 'database', 'firestore', 'storage', or 'hub'.");
    }
    if (options.database) {
        _databaseHost = getAddress(options.database.host, options.database.port);
    }
    if (options.firestore) {
        _firestoreHost = getAddress(options.firestore.host, options.firestore.port);
    }
    if (options.storage) {
        _storageHost = getAddress(options.storage.host, options.storage.port);
    }
    if (options.hub) {
        _hubHost = getAddress(options.hub.host, options.hub.port);
    }
}
/**
 * Use the Firebase Emulator hub to discover other running emulators. Call useEmulators() with
 * the result to configure the library to use the discovered emulators.
 *
 * @param hubHost the host where the Emulator Hub is running (ex: 'localhost')
 * @param hubPort the port where the Emulator Hub is running (ex: 4400)
 */
function discoverEmulators(hubHost, hubPort) {
    return __awaiter(this, void 0, void 0, function () {
        var hubAddress, res, options, data;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if ((hubHost && !hubPort) || (!hubHost && hubPort)) {
                        throw new Error("Invalid configuration hubHost=" + hubHost + " and hubPort=" + hubPort + ". If either parameter is supplied, both must be defined.");
                    }
                    hubAddress = hubHost && hubPort ? getAddress(hubHost, hubPort) : getHubHost();
                    return [4 /*yield*/, requestPromise(request.get, {
                            method: 'GET',
                            uri: "http://" + hubAddress + "/emulators"
                        })];
                case 1:
                    res = _a.sent();
                    if (res.statusCode !== 200) {
                        throw new Error("HTTP Error " + res.statusCode + " when attempting to reach Emulator Hub at " + hubAddress + ", are you sure it is running?");
                    }
                    options = {};
                    data = JSON.parse(res.body);
                    if (data.database) {
                        options.database = {
                            host: data.database.host,
                            port: data.database.port
                        };
                    }
                    if (data.firestore) {
                        options.firestore = {
                            host: data.firestore.host,
                            port: data.firestore.port
                        };
                    }
                    if (data.storage) {
                        options.storage = {
                            host: data.storage.host,
                            port: data.storage.port
                        };
                    }
                    if (data.hub) {
                        options.hub = {
                            host: data.hub.host,
                            port: data.hub.port
                        };
                    }
                    return [2 /*return*/, options];
            }
        });
    });
}
function getAddress(host, port) {
    if (host.includes('::')) {
        return "[" + host + "]:" + port;
    }
    else {
        return host + ":" + port;
    }
}
function getDatabaseHost() {
    if (!_databaseHost) {
        var fromEnv = process.env[DATABASE_ADDRESS_ENV];
        if (fromEnv) {
            _databaseHost = fromEnv;
        }
        else {
            console.warn("Warning: " + DATABASE_ADDRESS_ENV + " not set, using default value " + DATABASE_ADDRESS_DEFAULT);
            _databaseHost = DATABASE_ADDRESS_DEFAULT;
        }
    }
    return _databaseHost;
}
function getFirestoreHost() {
    if (!_firestoreHost) {
        var fromEnv = process.env[FIRESTORE_ADDRESS_ENV];
        if (fromEnv) {
            _firestoreHost = fromEnv;
        }
        else {
            console.warn("Warning: " + FIRESTORE_ADDRESS_ENV + " not set, using default value " + FIRESTORE_ADDRESS_DEFAULT);
            _firestoreHost = FIRESTORE_ADDRESS_DEFAULT;
        }
    }
    return _firestoreHost;
}
function getStorageHost() {
    if (!_storageHost) {
        var fromEnv = process.env[FIREBASE_STORAGE_ADDRESS_ENV] ||
            process.env[CLOUD_STORAGE_ADDRESS_ENV];
        if (fromEnv) {
            // The STORAGE_EMULATOR_HOST env var is an older Cloud Standard which includes http:// while
            // the FIREBASE_STORAGE_EMULATOR_HOST is a newer variable supported beginning in the Admin
            // SDK v9.7.0 which does not have the protocol.
            _storageHost = fromEnv.replace('http://', '');
        }
        else {
            console.warn("Warning: " + FIREBASE_STORAGE_ADDRESS_ENV + " not set, using default value " + STORAGE_ADDRESS_DEFAULT);
            _storageHost = STORAGE_ADDRESS_DEFAULT;
        }
    }
    return _storageHost;
}
function getHubHost() {
    if (!_hubHost) {
        var fromEnv = process.env[HUB_HOST_ENV];
        if (fromEnv) {
            _hubHost = fromEnv;
        }
        else {
            console.warn("Warning: " + HUB_HOST_ENV + " not set, using default value " + HUB_HOST_DEFAULT);
            _hubHost = HUB_HOST_DEFAULT;
        }
    }
    return _hubHost;
}
function parseHost(host) {
    var withProtocol = host.startsWith("http") ? host : "http://" + host;
    var u = new URL(withProtocol);
    return {
        hostname: u.hostname,
        port: Number.parseInt(u.port, 10)
    };
}
function getRandomAppName() {
    return 'app-' + new Date().getTime() + '-' + Math.random();
}
function getDatabaseUrl(databaseName) {
    return "http://" + getDatabaseHost() + "?ns=" + databaseName;
}
function getAppOptions(databaseName, projectId, storageBucket) {
    var appOptions = {};
    if (databaseName) {
        appOptions['databaseURL'] = getDatabaseUrl(databaseName);
    }
    if (projectId) {
        appOptions['projectId'] = projectId;
    }
    if (storageBucket) {
        appOptions['storageBucket'] = storageBucket;
    }
    return appOptions;
}
function initializeApp(accessToken, databaseName, projectId, storageBucket) {
    var _this = this;
    var appOptions = getAppOptions(databaseName, projectId, storageBucket);
    var app = firebase__default['default'].initializeApp(appOptions, getRandomAppName());
    if (accessToken) {
        var mockAuthComponent = new component.Component('auth-internal', function () {
            return ({
                getToken: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    return [2 /*return*/, ({ accessToken: accessToken })];
                }); }); },
                getUid: function () { return null; },
                addAuthTokenListener: function (listener) {
                    // Call listener once immediately with predefined accessToken.
                    listener(accessToken);
                },
                removeAuthTokenListener: function () { }
            });
        }, "PRIVATE" /* PRIVATE */);
        app._addOrOverwriteComponent(mockAuthComponent);
    }
    if (databaseName) {
        var _a = parseHost(getDatabaseHost()), hostname = _a.hostname, port = _a.port;
        app.database().useEmulator(hostname, port);
        // Toggle network connectivity to force a reauthentication attempt.
        // This mitigates a minor race condition where the client can send the
        // first database request before authenticating.
        app.database().goOffline();
        app.database().goOnline();
    }
    if (projectId) {
        var _b = parseHost(getFirestoreHost()), hostname = _b.hostname, port = _b.port;
        app.firestore().useEmulator(hostname, port);
    }
    if (storageBucket) {
        var _c = parseHost(getStorageHost()), hostname = _c.hostname, port = _c.port;
        app.storage().useEmulator(hostname, port);
    }
    /**
    Mute warnings for the previously-created database and whatever other
    objects were just created.
   */
    logger.setLogLevel(logger.LogLevel.ERROR);
    return app;
}
function loadDatabaseRules(options) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.databaseName) {
                        throw Error('databaseName not specified');
                    }
                    if (!options.rules) {
                        throw Error('must provide rules to loadDatabaseRules');
                    }
                    return [4 /*yield*/, requestPromise(request.put, {
                            method: 'PUT',
                            uri: "http://" + getDatabaseHost() + "/.settings/rules.json?ns=" + options.databaseName,
                            headers: { Authorization: 'Bearer owner' },
                            body: options.rules
                        })];
                case 1:
                    resp = _a.sent();
                    if (resp.statusCode !== 200) {
                        throw new Error(JSON.parse(resp.body.error));
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function loadFirestoreRules(options) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.projectId) {
                        throw new Error('projectId not specified');
                    }
                    if (!options.rules) {
                        throw new Error('must provide rules to loadFirestoreRules');
                    }
                    return [4 /*yield*/, requestPromise(request.put, {
                            method: 'PUT',
                            uri: "http://" + getFirestoreHost() + "/emulator/v1/projects/" + options.projectId + ":securityRules",
                            body: JSON.stringify({
                                rules: {
                                    files: [{ content: options.rules }]
                                }
                            })
                        })];
                case 1:
                    resp = _a.sent();
                    if (resp.statusCode !== 200) {
                        throw new Error(JSON.parse(resp.body.error));
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function loadStorageRules(options) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.rules) {
                        throw new Error('must provide rules to loadStorageRules');
                    }
                    return [4 /*yield*/, requestPromise(request.put, {
                            method: 'PUT',
                            uri: "http://" + getStorageHost() + "/internal/setRules",
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                rules: {
                                    files: [{ name: 'storage.rules', content: options.rules }]
                                }
                            })
                        })];
                case 1:
                    resp = _a.sent();
                    if (resp.statusCode !== 200) {
                        throw new Error(resp.body);
                    }
                    return [2 /*return*/];
            }
        });
    });
}
function clearFirestoreData(options) {
    return __awaiter(this, void 0, void 0, function () {
        var resp;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!options.projectId) {
                        throw new Error('projectId not specified');
                    }
                    return [4 /*yield*/, requestPromise(request['delete'], {
                            method: 'DELETE',
                            uri: "http://" + getFirestoreHost() + "/emulator/v1/projects/" + options.projectId + "/databases/(default)/documents",
                            body: JSON.stringify({
                                database: "projects/" + options.projectId + "/databases/(default)"
                            })
                        })];
                case 1:
                    resp = _a.sent();
                    if (resp.statusCode !== 200) {
                        throw new Error(JSON.parse(resp.body.error));
                    }
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * Run a setup function with background Cloud Functions triggers disabled. This can be used to
 * import data into the Realtime Database or Cloud Firestore emulator without triggering locally
 * emulated Cloud Functions.
 *
 * This method only works with Firebase CLI version 8.13.0 or higher.
 *
 * @param fn an function which returns a promise.
 */
function withFunctionTriggersDisabled(fn) {
    return __awaiter(this, void 0, void 0, function () {
        var hubHost, disableRes, result, enableRes;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    hubHost = getHubHost();
                    return [4 /*yield*/, requestPromise(request.put, {
                            method: 'PUT',
                            uri: "http://" + hubHost + "/functions/disableBackgroundTriggers"
                        })];
                case 1:
                    disableRes = _a.sent();
                    if (disableRes.statusCode !== 200) {
                        throw new Error("HTTP Error " + disableRes.statusCode + " when disabling functions triggers, are you using firebase-tools 8.13.0 or higher?");
                    }
                    result = undefined;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, , 4, 6]);
                    return [4 /*yield*/, fn()];
                case 3:
                    result = _a.sent();
                    return [3 /*break*/, 6];
                case 4: return [4 /*yield*/, requestPromise(request.put, {
                        method: 'PUT',
                        uri: "http://" + hubHost + "/functions/enableBackgroundTriggers"
                    })];
                case 5:
                    enableRes = _a.sent();
                    if (enableRes.statusCode !== 200) {
                        throw new Error("HTTP Error " + enableRes.statusCode + " when enabling functions triggers, are you using firebase-tools 8.13.0 or higher?");
                    }
                    return [7 /*endfinally*/];
                case 6: 
                // Return the user's function result
                return [2 /*return*/, result];
            }
        });
    });
}
function assertFails(pr) {
    return pr.then(function (v) {
        return Promise.reject(new Error('Expected request to fail, but it succeeded.'));
    }, function (err) {
        var errCode = (err && err.code && err.code.toLowerCase()) || '';
        var errMessage = (err && err.message && err.message.toLowerCase()) || '';
        var isPermissionDenied = errCode === 'permission-denied' ||
            errCode === 'permission_denied' ||
            errMessage.indexOf('permission_denied') >= 0 ||
            errMessage.indexOf('permission denied') >= 0;
        if (!isPermissionDenied) {
            return Promise.reject(new Error("Expected PERMISSION_DENIED but got unexpected error: " + err));
        }
        return err;
    });
}
function assertSucceeds(pr) {
    return pr;
}
function requestPromise(method, options) {
    return new Promise(function (resolve, reject) {
        var callback = function (err, resp, body) {
            if (err) {
                reject(err);
            }
            else {
                resolve({ statusCode: resp.statusCode, body: body });
            }
        };
        // Unfortunately request's default method is not very test-friendly so having
        // the caler pass in the method here makes this whole thing compatible with sinon
        method(options, callback);
    });
}

exports.apps = apps;
exports.assertFails = assertFails;
exports.assertSucceeds = assertSucceeds;
exports.clearFirestoreData = clearFirestoreData;
exports.database = database;
exports.discoverEmulators = discoverEmulators;
exports.firestore = firestore;
exports.initializeAdminApp = initializeAdminApp;
exports.initializeTestApp = initializeTestApp;
exports.loadDatabaseRules = loadDatabaseRules;
exports.loadFirestoreRules = loadFirestoreRules;
exports.loadStorageRules = loadStorageRules;
exports.useEmulators = useEmulators;
exports.withFunctionTriggersDisabled = withFunctionTriggersDisabled;
//# sourceMappingURL=index.cjs.js.map
